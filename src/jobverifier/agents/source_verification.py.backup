from __future__ import annotations

import json
import logging
import re
from dataclasses import dataclass
from typing import Any, Dict, List, Optional
from urllib.parse import unquote, urlparse

import requests
from bs4 import BeautifulSoup

from ..services import llm_available, structured_chat
from .base import Agent, JobContext
from .data_acquisition import TRUSTED_DOMAINS

try:  # Playwright is optional
    from playwright.sync_api import sync_playwright  # type: ignore[import]
    PLAYWRIGHT_AVAILABLE = True
except ImportError:  # pragma: no cover - environment without playwright
    PLAYWRIGHT_AVAILABLE = False

USER_AGENT = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 "
    "(KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
)
DUCKDUCKGO_HTML = "https://duckduckgo.com/html/"
PRESS_QUERY_TEMPLATE = "{company} press release"
EMPLOYEE_QUERY_TEMPLATE = 'site:linkedin.com/in "{company}" ({keywords})'

GENERIC_EMAIL_DOMAINS = {
    "gmail.com",
    "yahoo.com",
    "hotmail.com",
    "outlook.com",
    "protonmail.com",
    "icloud.com",
}

SUSPICIOUS_TLDS = {"xyz", "top", "store", "site", "click", "info"}

TRUSTED_ENTERPRISE_SUFFIXES = {
    "amazon.com",
    "amazon.jobs",
    "google.com",
    "alphabet.com",
    "microsoft.com",
    "apple.com",
    "meta.com",
    "linkedin.com",
    "oracle.com",
    "oraclecloud.com",
    "workday.com",
    "salesforce.com",
    "indeed.com",
    "glassdoor.com",
}

JOB_BOARD_DOMAINS = {
    "linkedin.com",
    "indeed.com",
    "glassdoor.com",
    "monster.com",
    "careerbuilder.com",
    "ziprecruiter.com",
    "lever.co",
    "greenhouse.io",
    "workday.com",
}

TRUSTED_BRAND_KEYWORDS = {
    "amazon",
    "google",
    "microsoft",
    "apple",
    "netflix",
    "meta",
    "linkedin",
    "indeed",
    "glassdoor",
    "monster",
    "ziprecruiter",
    "careerbuilder",
    "oracle",
}

logger = logging.getLogger(__name__)


@dataclass
class LinkedInProfile:
    url: str
    followers: Optional[str] = None
    industry: Optional[str] = None
    employee_count: Optional[str] = None


class SourceVerificationAgent(Agent):
    """Validates source credibility using heuristics and company intelligence gathering."""

    name = "source_verification"

    def __init__(self, request_timeout: int = 10) -> None:
        self.request_timeout = request_timeout

    def run(self, context: JobContext) -> JobContext:
        domain = urlparse(context.url).netloc.lower()
        email_domains = {email.split("@")[-1] for email in context.contact_emails}
        no_email_expected = bool(context.meta.get("no_email_expected"))

        if not email_domains:
            if no_email_expected:
                context.meta.setdefault("insights", {}).setdefault(
                    "source_verification", {}
                )["note"] = "No contact email expected for this platform"
            else:
            # Less severe if it's a major platform (they often don't list emails)
                if any(platform in domain for platform in ["linkedin.com", "indeed.com", "glassdoor.com", "oraclecloud.com", "oracle.com", "workday.com"]):
                    context.meta.setdefault("insights", {}).setdefault(
                        "source_verification", {}
                    )["note"] = "Platform typically hides recruiter emails"
                else:
                    context.add_flag("verification", "No contact email found in posting")
        else:
            for email_domain in email_domains:
                if email_domain in GENERIC_EMAIL_DOMAINS:
                    context.add_flag(
                        "verification",
                        f"Contact email uses generic domain: {email_domain}",
                    )
                elif email_domain.split(".")[-1] in SUSPICIOUS_TLDS:
                    context.add_flag(
                        "verification",
                        f"Email domain uses uncommon TLD: {email_domain}",
                    )
                elif email_domain not in domain:
                    context.add_flag(
                        "verification",
                        f"Contact email domain {email_domain} differs from source domain {domain}",
                    )

        if context.company and context.company.lower() in {"company not found", "unknown"}:
            context.add_flag("verification", "Company name is missing or generic")

        for channel in context.contact_channels:
            context.add_flag(
                "verification",
                f"Job relies on consumer messaging app: {channel}",
            )

        flagged_count = len(context.flags.get("verification", []))
        score = max(0, 100 - flagged_count * 20)
        context.meta["verification_score"] = score

        # Company intelligence gathering (merged from CompanyIntelligenceAgent)
        self._gather_company_intelligence(context)

        return context
